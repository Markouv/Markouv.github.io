<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-14%20Sorting%20+%20Selection/"/>
    <url>/2023/08/14/PS-14%20Sorting%20+%20Selection/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-14-Sorting-Selection"><a href="#PS-14-Sorting-Selection" class="headerlink" title="PS-14 Sorting + Selection"></a>PS-14 Sorting + Selection</h1><h1 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1. 快速排序"></a>1. 快速排序</h1><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>找到一个轴点，然后将元素与轴点比较，小的放在左边，大的放在右边</p><p><img src="/Users/markov/Desktop/blog/source/img/50f5424f5cbd0bfe2ef0e0c0e3cca4c.jpg" alt="50f5424f5cbd0bfe2ef0e0c0e3cca4c"></p><p>轴点：在本来有序向量中所属位置的点</p><p>但轴点不是一开始就有的，因此我们要培养轴点</p><h3 id="快速划分：LUG版"><a href="#快速划分：LUG版" class="headerlink" title="快速划分：LUG版"></a>快速划分：LUG版</h3><p>随机的选取候选者，比如 $elem[0]$，然后由 $lo$到 $hi$，交替向内移动，先从 $hi$开始比较，有小于轴点的即转到 $lo$，如此反复，各元素最多移动1次，因此划分只需 $O(n)$的时间</p><p>一般在选取候选者时有一步随机的交换，目的是使原本不随机的序列变得随机</p><p><strong>递归深度</strong></p><p>此算法所需额外空间仅为 $O(1)$，但没考虑递归的深度，递归深度可能会有最坏的情况达到 $O(n)$，</p><p>但是概率非常非常低，期望来讲大概率还是 $O(logn)$，因此我们认为该算法还是就地的</p><p><strong>迭代</strong></p><p>或者也可以采取迭代的办法，大任务先入栈，小任务后入栈，需要的辅助栈空间也不过 $O(logn)$</p><p><strong>比较次数</strong></p><p>$T(n)&#x3D;(n-1)+\frac{1}{n}\sum_{k&#x3D;0}^{n-1}[T(k)+T(n-k-1)]&#x3D;(n-1)+\frac{2}{n}\sum_{k&#x3D;0}^{n-1}T(k)$</p><p>经过一系列化简</p><p>$\frac{T(n)}{n+1}-\frac{T(n-1)}{n}&#x3D;\frac{4}{n+1}-\frac{2}{n}$</p><p>经过累加法得</p><p>$\frac{T(n)}{n+1}\approx 2\ln n$</p><p>$T(n)\approx 1.386\cdot nlogn$</p><p>也可以采用后向分析的方法：</p><p><img src="/Users/markov/Desktop/blog/source/img/3512a0b41fb9f022cded7e3682c2bd5.jpg" alt="3512a0b41fb9f022cded7e3682c2bd5"></p><h3 id="几种排序算法对比"><a href="#几种排序算法对比" class="headerlink" title="几种排序算法对比"></a>几种排序算法对比</h3><p><img src="/Users/markov/Desktop/blog/source/img/2032df4966842da313a6fb512cce2fc.jpg" alt="2032df4966842da313a6fb512cce2fc"></p><h3 id="快速划分：DUP版"><a href="#快速划分：DUP版" class="headerlink" title="快速划分：DUP版"></a>快速划分：DUP版</h3><p>大量元素重复时，会导致划分的失衡，使得递归深度过大，DUP版将原算法中比较的等号去掉，这样可以缓解失衡的问题，降低递归的深度</p><h3 id="快速划分：LGU版"><a href="#快速划分：LGU版" class="headerlink" title="快速划分：LGU版"></a>快速划分：LGU版</h3><p>顺序遍历元素，逐一和轴点比较，less则放在序列的L部分（实则是和G中第一个元素交换），greater则不需要移动，直接继续拓展，是非常简单的一种算法</p><p><img src="/Users/markov/Desktop/blog/source/img/6ae2ecf648a03af380f21191d1701c6.jpg" alt="6ae2ecf648a03af380f21191d1701c6"></p><p>以上算法都存在不稳定的问题</p><h1 id="2-选取"><a href="#2-选取" class="headerlink" title="2. 选取"></a>2. 选取</h1><h3 id="QuickSelect"><a href="#QuickSelect" class="headerlink" title="QuickSelect"></a>QuickSelect</h3><p>经过反复地做quicksort中的partition操作，最终选出第k大的元素</p><p>期望的复杂度为 $O(n)$，但仍存在最坏情况！</p><h3 id="LinearSelect"><a href="#LinearSelect" class="headerlink" title="LinearSelect"></a>LinearSelect</h3><p><img src="/Users/markov/Desktop/blog/source/img/6f47805e333cbe915661fed600695a1.jpg" alt="6f47805e333cbe915661fed600695a1"></p><h1 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h1><p>相隔一定步长的插值排序，步长按特定的序列从大到小变化</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-13%20String/"/>
    <url>/2023/08/14/PS-13%20String/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-13-String"><a href="#PS-13-String" class="headerlink" title="PS-13 String"></a>PS-13 String</h1><p>[TOC]</p><h1 id="1-串"><a href="#1-串" class="headerlink" title="1. 串"></a>1. 串</h1><p>实际上就是字符串</p><h1 id="2-模式匹配"><a href="#2-模式匹配" class="headerlink" title="2. 模式匹配"></a>2. 模式匹配</h1><p>$Text$和 $Pattern$的匹配</p><h3 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h3><p>抓住 $Pattern$的头，和 $Text$串的每个元素逐一比对，如果匹配成功再深入 $Pattern$串比对</p><p>最好情况： $\Omega (n)$</p><p>最坏情况： $O(n\cdot m)$</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><img src="/Users/markov/Desktop/blog/source/img/3d55590162be0cc924c1323ce29f98b.jpg" alt="3d55590162be0cc924c1323ce29f98b"></p><p>关键在于构建一个表，记录每个位置如果匹配失败，则更新成 $Pattern$串的 $j$前面的哪一个元素，即 $t$</p><p><strong>查询表</strong></p><p>当前 $j$个元素已经匹配时，我们只需找到在已匹配的串中，最长的前缀和后缀自匹配，然后就能确定 $t$，依此来构建查询表 $next[0,m)$，在 $j$处失配，将其换为 $next[j]$即可</p><p>$next[0]$恒为-1</p><p><strong>为什么要取最长的自匹配？为了使移动的距离最小，不至于回溯</strong></p><p><strong>构造next[]表</strong></p><p>next[0]必然恒为-1，属于通配符</p><p>next[1]按照规则也必然为0</p><p>当已知next[0]，…，next[j]时，如何确定next[j+1]？</p><p>其实就是让0~j去自匹配，先看j和next[j]是否匹配，如果匹配next[j+1]就在next[j]的基础上+1，如果不匹配，就再看j和next[next[j]]是否匹配，匹配则在此基础上+1，否则继续查询下去</p><p><strong>复杂度</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/ea1ada7716d4a841827518b5322587f.jpg" alt="ea1ada7716d4a841827518b5322587f"></p><p>绿色和红色的比对，落到一条线上也不过 $O(n)$，需要考虑的是黄色的比对</p><p><img src="/Users/markov/Desktop/blog/source/img/cb7483acadb758959fabfd07d7a5022.jpg" alt="cb7483acadb758959fabfd07d7a5022"></p><p>怎么设计出来的？？？</p><p><strong>再改进</strong></p><p>KMP算法有一种很笨的情况，就是j和next[j]的元素是一样的，这样会导致在替换过后也必然失配，我们要避免这样的情况发生</p><p>在构造查询表时，在每个元素赋值之前，要先看这个元素和赋值的元素是否相等，否则要赋将赋值元素的next[]（由于不变性，赋值元素的next[]必然与其本身不相等，因此这样一次即可）</p><p><strong>注意</strong></p><p>当匹配的字符集越小，成功的概率越大，KMP算法的优势才明显，否则蛮力算法期望上来讲也不过走两步，性能也是 $O(2n)$</p><h3 id="BM算法：BC策略"><a href="#BM算法：BC策略" class="headerlink" title="BM算法：BC策略"></a>BM算法：BC策略</h3><p>每次比对从 $Pattern$的末尾开始，如果发生失配，找到 $Pattern$失配位置前有没有对应失配位置 $Text$的字符，如果有则移动到对应位置，再从后往前比对，没有则整体后移</p><p><strong>bc[]表</strong></p><p>构造字符集的哈希表，对应字符存入 $Pattern$中秩最大的位置，在应用时，如果 $Text$字符在 $Pattern$失配位置之后，则 $Pattern$只移动一位即可</p><p><strong>性能</strong></p><p>$O(n&#x2F;m)$</p><p>最差仍是蛮力算法</p><p>单次匹配概率越小，P越长，优势越明显</p><h3 id="BM算法：GS策略"><a href="#BM算法：GS策略" class="headerlink" title="BM算法：GS策略"></a>BM算法：GS策略</h3><p>找到匹配后缀的自匹配（或部分匹配）前缀，与KMP的策略相同</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p><img src="/Users/markov/Desktop/blog/source/img/10c168d09b6790f7986f9c1f681fc7a.jpg" alt="10c168d09b6790f7986f9c1f681fc7a"></p><h1 id="3-Karp-Rabin算法"><a href="#3-Karp-Rabin算法" class="headerlink" title="3. Karp-Rabin算法"></a>3. Karp-Rabin算法</h1><h3 id="串即是数"><a href="#串即是数" class="headerlink" title="串即是数"></a>串即是数</h3><p>哥德尔的思想，世间万物都能用自然数来表示！</p><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>将 $Text$串的每一指纹换算成数，再用 $hash()$压缩存入散列中，把 $Pattern$也转化，再与散列比对，比对成功之后，再取出原指纹比对</p><p>相邻指纹之间的散列可由上一指纹求出下一指纹，比如求余，减去头的影响，加上尾部的影响即可</p><h1 id="4-键树"><a href="#4-键树" class="headerlink" title="4. 键树"></a>4. 键树</h1><p>？？？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-12%20Priority%20Queue/"/>
    <url>/2023/08/14/PS-12%20Priority%20Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-12-Priority-Queue"><a href="#PS-12-Priority-Queue" class="headerlink" title="PS-12 Priority Queue"></a>PS-12 Priority Queue</h1><p>[TOC]</p><h1 id="1-优先级队列"><a href="#1-优先级队列" class="headerlink" title="1. 优先级队列"></a>1. 优先级队列</h1><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>使getMax()，delMax()，insert()均只需 $O(logn)$的时间，并且实现起来很简单，不必维护全序关系</p><h3 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h3><p><img src="/Users/markov/Desktop/blog/source/img/ffd3f8850a8185b8e9445d41fe588af.jpg" alt="ffd3f8850a8185b8e9445d41fe588af"></p><p>要求在逻辑意义上， $\forall i,H[i]≤H[parent(i)]$</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>先在尾部插入，然后和其逻辑次序的父亲比较，如果更大则交换，然后就这样一层一层比较，逐层上滤，直到不大于父亲或到达顶端，所需时间为 $O(logn)$</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>接口只实现删除极大元素即顶部元素，将尾部元素拿到顶上来，然后与其逻辑的两个孩子比较，取三者中的最大者当父亲，就这样逐层下滤，直到满足条件为止，所需时间为 $O(logn)$</p><h1 id="2-批量建堆"><a href="#2-批量建堆" class="headerlink" title="2. 批量建堆"></a>2. 批量建堆</h1><h3 id="自上而下的上滤（蛮力算法）"><a href="#自上而下的上滤（蛮力算法）" class="headerlink" title="自上而下的上滤（蛮力算法）"></a>自上而下的上滤（蛮力算法）</h3><p>自顶层元素，逐一上滤，最终建堆</p><p>但是所需时间会达到 $O(nlogn)$，那还不如直接全排序</p><h3 id="自下而上的下滤"><a href="#自下而上的下滤" class="headerlink" title="自下而上的下滤"></a>自下而上的下滤</h3><p>从尾部的内部节点开始，从后往前逐一下滤，最终建堆</p><p>不变性：顶层元素下滤到两个满足堆序性的子堆中，全局必然满足堆序性</p><p>在这种情况下，每个内部节点下滤所花时间正比于其高度而非深度，而高度低的内部节点更多，所以显然比正比于深度的蛮力算法更省时间</p><p><img src="/Users/markov/Desktop/blog/source/img/8ae48f81a930cc03a061c7227b9968a.jpg" alt="8ae48f81a930cc03a061c7227b9968a"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>insert()最坏情况是 $O(logn)$，平均情况是多少？</p><p>平均情况下，由于有一半的元素分布在最底层，插入一个元素向上攀升一层的概率是 $1&#x2F;2$，这样攀升高度构成了一个几何分布，平均高度为 $O(2)$</p><h1 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h1><p><img src="/Users/markov/Desktop/blog/source/img/87f9daabc4c578869b81378ae9d6337.jpg" alt="87f9daabc4c578869b81378ae9d6337"></p><p>首先整体序列构造成一个完全二叉堆，然后逐一删除顶部元素（实际上就是把极大元素扔到尾部去），这样就实现了整体的堆排序</p><p>复杂度是 $O(n+nlogn)$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-09%20Dictionary/"/>
    <url>/2023/08/14/PS-09%20Dictionary/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-09-Dictionary"><a href="#PS-09-Dictionary" class="headerlink" title="PS-09 Dictionary"></a>PS-09 Dictionary</h1><p>[TOC]</p><h1 id="1-词典"><a href="#1-词典" class="headerlink" title="1. 词典"></a>1. 词典</h1><p>词条的key和value突破了数字的限制</p><h3 id="散列：原理"><a href="#散列：原理" class="headerlink" title="散列：原理"></a>散列：原理</h3><p>可能存在的key数量很多，但实际存在的key很少，为了节省空间，我们采用散列表</p><p><img src="/Users/markov/Desktop/blog/source/img/32855079dcb7ccc5f1f93c829c4ebae.jpg" alt="32855079dcb7ccc5f1f93c829c4ebae"></p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>有可能出现 $key_{1}≠key_{2}$，但是 $hash(key_{1})&#x3D;hash(key_{2})$的情况</p><h1 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2. 散列函数"></a>2. 散列函数</h1><p><img src="/Users/markov/Desktop/blog/source/img/419895227157f83a9939d976997233b.jpg" alt="419895227157f83a9939d976997233b"></p><h3 id="除余法"><a href="#除余法" class="headerlink" title="除余法"></a>除余法</h3><p>除余时选取素数，可使数据对散列表的覆盖最充分，分布最均匀</p><h3 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h3><p><img src="/Users/markov/Desktop/blog/source/img/eaf65b8e882e0a37a729f3b3c72ded4.jpg" alt="eaf65b8e882e0a37a729f3b3c72ded4"></p><p>散列函数设计的越随机越好</p><h3 id="伪随机数法"><a href="#伪随机数法" class="headerlink" title="伪随机数法"></a>伪随机数法</h3><p>因各平台随机数生成方法差异很大，该方法可移植性差</p><h1 id="3-排解冲突"><a href="#3-排解冲突" class="headerlink" title="3. 排解冲突"></a>3. 排解冲突</h1><h3 id="开放散列"><a href="#开放散列" class="headerlink" title="开放散列"></a>开放散列</h3><p><strong>多槽位</strong></p><p>预先将每个bucket细分成几个槽</p><p>但是细分程度无法确定，可能不够，也可能空间浪费</p><p><strong>公共溢出区</strong></p><p>将溢出元素放在额外开辟的区域中，但是一旦溢出就要遍历溢出区</p><p><strong>独立链</strong></p><p>每个bucket里存入一个链表用以存放冲突，但是指针本身会占用很多空间，调用也很慢</p><h3 id="封闭散列"><a href="#封闭散列" class="headerlink" title="封闭散列"></a>封闭散列</h3><p><strong>线性试探</strong></p><p>从 $hash(key)$的对应位置开始试探如果失败则转向下一个桶，直到成功或抵达空桶（失败）</p><p>插入：插入到线性试探为空的位置</p><p>删除：不能直接删除，因为可能会使线性试探提前中断，要采取懒惰删除的策略</p><p><strong>懒惰删除</strong></p><p>仅将删除位置做一个标记</p><p>当查找时，标记位置看作非空，但是必不匹配</p><p>当插入时，标记位置看作空，可以插入元素</p><h3 id="重散列"><a href="#重散列" class="headerlink" title="重散列"></a>重散列</h3><p>当装填因子过大时，考虑开辟一个更大的散列表，然后将原来散列表的元素集体迁移到新的散列，注意迁移时不可以简单的线性迁移，要回归到hash()之前的key，按照新的散列规则重新计算插入</p><p><strong>平方试探</strong></p><p>但发生冲突时，可以聪明地跳出冲突区域，减少试探次数</p><p>当表长 $M$为素数时，装填因子 $\lambda&lt;0.5$，可以保证散列表正常运行</p><p>否则可能会出现在几个元素中反复横跳的情况</p><p><strong>双向平方试探</strong></p><p>交替地沿两个方向试探</p><p>取表长为 $M&#x3D;4k+3$，可以保证试探前 $M$项均互异</p><h1 id="4-桶排序"><a href="#4-桶排序" class="headerlink" title="4. 桶排序"></a>4. 桶排序</h1><p><img src="/Users/markov/Desktop/blog/source/img/a1dec55dd1026e0a4b5c3b364a97dbd.jpg" alt="a1dec55dd1026e0a4b5c3b364a97dbd"></p><p><img src="/Users/markov/Desktop/blog/source/img/00bbe90ddf4ba8bee277ab6f7d40947.jpg" alt="00bbe90ddf4ba8bee277ab6f7d40947"></p><h3 id="最大缝隙"><a href="#最大缝隙" class="headerlink" title="最大缝隙"></a>最大缝隙</h3><p>找出 $n$个点中间隔最大的一段，采用分桶排序，算法复杂度可达 $O(n)$</p><p><img src="/Users/markov/Desktop/blog/source/img/76270e5235418d36ab00f0abb6d9430.jpg" alt="76270e5235418d36ab00f0abb6d9430"></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>关键码由多个域组成</p><p>排序时由低位到高位，可保证算法的稳定性</p><p><strong>整数排序</strong></p><p>每个元素化为 $d$个域，可直接套用基数排序算法</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>“小集合+大数据”类型</p><p>按数字大小排序之后，还要按种类排序</p><p>经过分桶统计出种类的数量，确定每个种类对应的区间</p><p>自后向前扫描，将对应的种类放到尾部，然后计数减一</p><p><strong>为什么自后向前？因为分桶的时候最终记的是每个种类最末尾位置的指针</strong></p><p>空间复杂度 $O(n)$</p><h3 id="跳转表"><a href="#跳转表" class="headerlink" title="跳转表"></a>跳转表</h3><p>每个元素的塔高期望为2，所以空间复杂度期望为 $O(n)$</p><p>整体期望塔高为 $O(logn)$</p><p><strong>查找时间复杂度</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/c2246e7f7a321ac3b0f27c165804351.jpg" alt="c2246e7f7a321ac3b0f27c165804351"></p><p>纵向跳转为层高： $O(logn)$</p><p>横向跳转时，每次都落在塔顶上，每层的塔顶期望的只有2个，因此也为 $O(logn)$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-08%20Advanced%20Search%20Trees/"/>
    <url>/2023/08/14/PS-08%20Advanced%20Search%20Trees/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-08-Advanced-Search-Trees"><a href="#PS-08-Advanced-Search-Trees" class="headerlink" title="PS-08 Advanced Search Trees"></a>PS-08 Advanced Search Trees</h1><h1 id="1-Splay-Tree（伸展树）"><a href="#1-Splay-Tree（伸展树）" class="headerlink" title="1. Splay Tree（伸展树）"></a>1. Splay Tree（伸展树）</h1><p>由于访问的局部性，访问一个节点以后可能不久就再次访问，于是把每次访问的节点移到树根，这样的树叫做伸展树</p><p>每次移动都要通过zig,zag一层一层地爬上去，如果周期性地访问，分摊复杂度可达 $\Omega (n^{2})$</p><h3 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h3><p><img src="/Users/markov/Desktop/blog/source/img/4db243df40e8eb226f784a6af1ab8eb.jpg" alt="4db243df40e8eb226f784a6af1ab8eb"></p><p>每次伸展要一起看两层，从祖父旋转</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h3><p>先通过search()找到不大于插入节点的最大节点并伸展至根，然后再在根的头上生成新节点</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>通过search()找到目标节点，伸展至根然后删除，删除后从右子树中找到最小节点伸展至根作为新的根</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>分摊复杂度为 $O(logn)$</p><p><strong>分析</strong></p><p>运用势能分析法</p><h1 id="2-B树"><a href="#2-B树" class="headerlink" title="2. B树"></a>2. B树</h1><ul><li>存储器规模增长速度远远小于问题规模增长速度</li><li>增大存储器规模会使访问速度变慢</li><li>存储器有内部级联结构，不同级联结构访问速度不同，访问内存1s，访问磁盘则需要一天</li><li>相邻存储级别之间的数据传输在算法时间中占的更多</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>每d代合并为1个超级节点，每个节点有 $m&#x3D;2^{d}$条支路， $m-1$个关键码</p><p>内部节点分支个数为 $m&#x2F;2≤n≤m$，关键码个数为 $n-1$</p><p>但是根节点关键码个数 $n≥1$即可</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在每个节点中顺序查找，查找失败则转到下一层继续查找（相当于1次I&#x2F;O操作）</p><p>运行时间 $O(logn)$</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>先通过search()找到插入位置，如果上溢，取出中位数关键码移到上层，原节点分裂为两个</p><p>若父亲也上溢，用同样的办法分裂，若上溢向上传播，则逐层解决直到根</p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>先通过search()找到删除位置，如果不是叶子节点，则找到直接后继与其交换，然后在直接后继的位置将其删除</p><p>如果下溢，看左右兄弟的规模：</p><ul><li>如果左兄弟有盈余，将左兄弟的最大关键码移到父亲节点上来，将父亲节点的分界关键码移到被删除的节点中</li><li>如果右兄弟有盈余，将右兄弟的最小关键码移到父亲节点上来，将父亲节点的分界关键码移到被删除的节点中</li><li>如果左右兄弟都不够，则选择左兄弟或右兄弟，将其父亲的分界关键码拿下来两个节点合并为一个节点，但可能引起向上传播，则逐层修复</li></ul><h1 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h1><p><img src="/Users/markov/Desktop/blog/source/img/19b51d0fbf27991da17157afbacdbc2.jpg" alt="19b51d0fbf27991da17157afbacdbc2"></p><p>将红节点高度提升至与其黑父亲等高，实际上相当于一个(2,4)-B树，也是BBST</p><h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><p>search()找到插入位置，然后染红（根节点要染成黑的），此时规则3可能会违反，可能会出现双红的情况</p><p><strong>双红修正</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/04b75ec9cc75f70b106aa86208fa4d7.jpg" alt="04b75ec9cc75f70b106aa86208fa4d7"></p><p>经过3-4重构之后，将中间节点染黑，子节点染红</p><p><img src="/Users/markov/Desktop/blog/source/img/5c938ded426d6d213c35582e88f175d.jpg" alt="5c938ded426d6d213c35582e88f175d"></p><p>相当于B树上溢，将g染红上升1层，然后将p, u染黑</p><p>这样可能引起双红向上传播，则逐层实施双红解决策略</p><p><strong>复杂度</strong></p><p>$O(logn)$次重染色</p><p>$O(1)$次旋转（旋转过后必然全局恢复）</p><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>按照原BST删除操作删除，3、4规则可能会违反</p><p><img src="/Users/markov/Desktop/blog/source/img/aa680f5c143d56e34dd03015fcb9fd9.jpg" alt="aa680f5c143d56e34dd03015fcb9fd9"></p><p><strong>双黑</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/9e04d42570698e624a5919a49774869.jpg" alt="9e04d42570698e624a5919a49774869"></p><p>3-4重构</p><p><img src="/Users/markov/Desktop/blog/source/img/b547cd00db3bc766dba512205da1bf6.jpg" alt="b547cd00db3bc766dba512205da1bf6"></p><p><img src="/Users/markov/Desktop/blog/source/img/20d87921fc6d1281f143bdbb7ed26e4.jpg" alt="20d87921fc6d1281f143bdbb7ed26e4"></p><p>局部修复之后，父节点会下溢，仍然可以看成原父节点是个黑节点，从而进行双黑修正</p><p><img src="/Users/markov/Desktop/blog/source/img/57b257d49517194bbfd38353fc7c205.jpg" alt="57b257d49517194bbfd38353fc7c205"></p><p><strong>复杂度</strong></p><p>$O(\log n)$次重染色</p><p>$O(1)$次旋转（旋转过后必然全局恢复）</p><p>红黑树考前再看看！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-07%20Search%20Tree%20Applications/"/>
    <url>/2023/08/14/PS-07%20Search%20Tree%20Applications/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-07-Search-Tree-Applications"><a href="#PS-07-Search-Tree-Applications" class="headerlink" title="PS-07 Search Tree Applications"></a>PS-07 Search Tree Applications</h1><p>[TOC]</p><h1 id="1-Range-Query"><a href="#1-Range-Query" class="headerlink" title="1. Range Query"></a>1. Range Query</h1><h3 id="1-D"><a href="#1-D" class="headerlink" title="1-D"></a>1-D</h3><p>将所有点组织成一个有序的向量，通过二分查找找到最右的边界，然后反向report，这样的复杂度是 $O(logn+r)$， $r$是report所需的固定时间无法优化</p><h3 id="2-D"><a href="#2-D" class="headerlink" title="2-D"></a>2-D</h3><p>点分布在二维平面上，用上闭下开，右闭左开的区间去框住</p><h1 id="2-K-D-Tree"><a href="#2-K-D-Tree" class="headerlink" title="2. K-D Tree"></a>2. K-D Tree</h1><h3 id="2-D-1"><a href="#2-D-1" class="headerlink" title="2-D"></a>2-D</h3><p>先递归地划分区域</p><p>找到中间点，奇数层竖直划分，偶数层水平划分，划分区域为右上闭，左下开</p><p>最终K-D树为 $logn$层</p><p><strong>Quadtree</strong></p><p>将区域四等分四等分的划分，但是可能会出现空的区域</p><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p><img src="/Users/markov/Desktop/blog/source/img/13cbe466ce1581f6c8e0dd6a9eefbb4.jpg" alt="13cbe466ce1581f6c8e0dd6a9eefbb4"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>构建K-D树的时间复杂度为 $O(nlogn)$</p><p>空间复杂度为 $O(n)$</p><p>查询复杂度为 $O(\sqrt{n}+r)$为什么？？？</p><h1 id="3-Interval-Tree（区间树）"><a href="#3-Interval-Tree（区间树）" class="headerlink" title="3. Interval Tree（区间树）"></a>3. Interval Tree（区间树）</h1><p>在一个区间的集合中找到包含一个点的所有区间</p><p>首先找到所有端点中最中间的那个点，以这个点做划分，包含这个点的留下，在这个点左边的区间放到左孩子中，在这个点右边的区间放到右孩子中，然后递归地生成Interval tree</p><p><strong>深度</strong></p><p>左右孩子中的区间数都 $≤n&#x2F;2$，全树的高度必然为 $O(logn)$</p><p><strong>节点存储方式</strong></p><p>用两个列表分别存储每个区间的左端点和右端点，左端点按从小到大排列，右端点按从大到小排列</p><p><strong>查询</strong></p><p>对每一个查询点，和每个节点中分割中点比较，假设大于中点，则对右端点从大到小比较，如果查询点在对应区间中，则report，再递归查询右子树；如果查询点等于中间分割点，则直接report该节点</p><h1 id="4-Segment-Tree（线段树）"><a href="#4-Segment-Tree（线段树）" class="headerlink" title="4. Segment Tree（线段树）"></a>4. Segment Tree（线段树）</h1><p>同样的目的，但是以所有区间的端点作为分割点分割整个数轴，得到 $2n$个线段，在每个线段中存储包含这个线段的区间，这样组成的树为线段树</p><p>但如果分割地过于细致会导致空间复杂度过大为 $\Omega (n^{2})$</p><p>考虑将两个存储在相同父亲节点的两个孩子中的属于同一区间的线段合并，最终所有区间的存储空间为 $O(nlogn)$为什么？？</p><p>查询时间为 $O(logn)$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-06%20Binary%20Search%20Trees/"/>
    <url>/2023/08/14/PS-06%20Binary%20Search%20Trees/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-06-Binary-Search-Tree"><a href="#PS-06-Binary-Search-Tree" class="headerlink" title="PS-06 Binary Search Tree"></a>PS-06 Binary Search Tree</h1><p>[TOC]</p><h1 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1. 二叉搜索树"></a>1. 二叉搜索树</h1><p><strong>在中序遍历的意义下，搜索树必然单调非降</strong></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>search()</li><li>insert()</li><li>remove()</li></ul><p><strong>search</strong></p><p>采取减而治之的策略，类似在做二分查找</p><p><strong>insert</strong></p><p>借助search()确定插入位置，然后由插入位置的父亲生出新的孩子</p><p>插入位置都在叶子节点</p><p><strong>remove</strong></p><p>定位目标节点，当目标节点只有一个子树时，直接用子树替代；当有两个子树时，找到直接前驱或后继，与目标节点替换位置，然后在新的位置删除目标节点</p><h3 id="期望树高"><a href="#期望树高" class="headerlink" title="期望树高"></a>期望树高</h3><p>从 $n$个元素随机排列的意义上，生成树的期望高度为 $logn$</p><p>从 $n$个节点随机生成一棵树的意义上，树的种类数是一个卡特兰数，期望树高为 $\sqrt{n}$</p><p>从理想随机的角度来看，二叉搜索树的树高是可以接受的，但是理想随机很难存在，原因有：</p><ul><li>局部性</li><li>关联性</li><li>单调性</li><li>周期性</li></ul><p>因此还需要做平衡化处理</p><h1 id="2-平衡树"><a href="#2-平衡树" class="headerlink" title="2. 平衡树"></a>2. 平衡树</h1><p>zig：顺时针旋转</p><p>zag：逆时针旋转</p><p>单次恢复平衡所需时间为 $O(logn)$</p><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><strong>要求每个节点的两个子树高度相差不超过1，左右子树高度差为平衡因子</strong></p><p><strong>渐近平衡</strong></p><p>考察高度为 $h$的AVL树，总节点个数为 $S(h)$</p><p>则 $S(h)&#x3D;1+S(h-1)+S(h-2)$</p><p>$S(h)+1&#x3D;S(h-1)+1+S(h-2)+1$</p><p>即 $fib(n+3)&#x3D;fib(n+2)+fib(n+1)$</p><p>所以 $S(h)&#x3D;fib(n+3)-1$是指数规模的，反过来 $n$个节点构成的AVL树的树高为对数量级</p><p><strong>插入</strong></p><p>插入一次之后失衡的最低者不会低于插入节点的祖父，也有可能引发连锁失衡，但是经过一次旋转之后就可以全局恢复</p><p><strong>删除</strong></p><p>有可能删除节点的父亲就失衡了，但是经过一次旋转恢复后，祖先可能失衡从而引发连锁的效应，因此恢复需要 $O(logn)$的时间</p><p><strong>3-4重构</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-05%20Binary%20Trees/"/>
    <url>/2023/08/14/PS-05%20Binary%20Trees/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-05-Binary-Trees"><a href="#PS-05-Binary-Trees" class="headerlink" title="PS-05 Binary Trees"></a>PS-05 Binary Trees</h1><p>[TOC]</p><h1 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h1><p>一种连通无环图</p><p>节点深度即为从根节点到达该节点的路径长度</p><p>根的深度为0</p><p>所有叶子中深度最大者称为子树的高度</p><p>空树高度取作-1</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><p>用父亲节点+孩子节点表示</p><p>任何一棵有根有序的多叉树都可以转化为二叉树</p><p><strong>满二叉树</strong></p><p>高为 $h$的二叉树节点数 $n&#x3D;2^{h+1}-1$</p><p><strong>真二叉树</strong></p><p>每个节点都有两个孩子</p><h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/Users/markov/Desktop/blog/source/img/b83ad580ec96c01a25bf966e23d4b2a.jpg" alt="b83ad580ec96c01a25bf966e23d4b2a"></p><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">x, visit</span>)&#123;<br><span class="hljs-title function_">visit</span>(x);<br><span class="hljs-title function_">traverse</span>(x-&gt;lc, visit);<br><span class="hljs-title function_">traverse</span>(x-&gt;rc, visit);<br>&#125;<br></code></pre></td></tr></table></figure><p>制约：递归深度有限</p><p><strong>改进</strong></p><p>先访问最左侧的一根藤，然后自下而上访问藤上每个右子树，每个右子树仍以同样的方式遍历</p><p>用栈来实现</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> <span class="hljs-title function_">tarverse</span>(<span class="hljs-params">x, visit</span>)&#123;<br><span class="hljs-title function_">traverse</span>(x-&gt;lc, visit);<br><span class="hljs-title function_">visit</span>(x);<br><span class="hljs-title function_">traverse</span>(x-&gt;rc, visit);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><p>先从最左侧的藤走下去，走到最深处，然后从下而上遍历藤上节点以及右子树</p><p>用栈来实现</p><p>在中序遍历意义下，如果有右孩子，直接后继为最靠左的右后代，</p><p>如果没有，反过来想，应是以该节点为直接前驱的节点</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">void</span> <span class="hljs-title function_">tarverse</span>(<span class="hljs-params">x, visit</span>)&#123;<br><span class="hljs-title function_">traverse</span>(x-&gt;lc, visit);<br><span class="hljs-title function_">traverse</span>(x-&gt;rc, visit);<br><span class="hljs-title function_">visit</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>尽量沿左走，如果左走不了，则向右，直到无路可走，然后自下而上遍历节点以及右子树（如果有的话）</p><p>还是用栈来实现</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>（广度优先搜索hhh）</p><p>运用队列来迭代</p><p><strong>完全二叉树</strong></p><ul><li>底层叶子只居于最底下两层，且最后一层的叶子都靠在最左侧的真二叉树</li><li>叶子节点不比内部节点少，至多多出来一个</li><li>辅助队列最大规模 $n&#x2F;2$向上取整</li></ul><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>可以用两个向量或列表来重构二叉树</p><p><strong>先序&#x2F;后序+中序</strong></p><p>完全可行，在先序的头或后序的尾找到中间节点，再在中序中找到中间节点分割即可，左边就对应左子树，右边则对应右子树</p><p><strong>先序+后序</strong></p><p>当原二叉树有左右两棵子树时，通过查找两棵子树的根节点也能把左右子树对应的序列区分开来，但是当只有一棵子树时，就不行了</p><h1 id="3-Huffman-编码树"><a href="#3-Huffman-编码树" class="headerlink" title="3. Huffman 编码树"></a>3. Huffman 编码树</h1><p>关键：不同字符的编码互不为前缀（Prefix-Free Code)</p><p>平均编码长度等于叶节点的平均深度</p><p><strong>最优编码树</strong></p><p>平均编码长度最小者，最特别的是真完全树，否则可以通过交换节点来实现最优</p><p>但实际上不同字符的出现频率并不相同，叶节点的平均深度要加上频率的权重，此时完全树就未必是最优编码树</p><p>考虑频率时，要把频率高的字符放在高处，频率低的字符放在低处</p><p><strong>贪心策略</strong></p><p>所有字符单节点作为一棵树，组成森林，按频率将树从小到大排序，取出频率最小的两棵树组成一棵新的树，然后放回森林中，如此循环往复，最终组成一棵完整的树，符合频率低的在低处，频率高的在高处</p><p>如果采用向量或者列表，复杂度要 $O(n^{2})$</p><p>如果采用优先级队列，复杂度为 $O(nlogn)$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-04%20Stack%20+%20Queue/"/>
    <url>/2023/08/14/PS-04%20Stack%20+%20Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-04-Stack-Queue"><a href="#PS-04-Stack-Queue" class="headerlink" title="PS-04 Stack + Queue"></a>PS-04 Stack + Queue</h1><p>[TOC]</p><h1 id="1-栈的接口与实现"><a href="#1-栈的接口与实现" class="headerlink" title="1. 栈的接口与实现"></a>1. 栈的接口与实现</h1><p>栈只能在栈顶插入和删除，后进先出</p><ul><li>接口<ul><li>size() &#x2F; empty()</li><li>push()</li><li>pop()</li><li>top()</li></ul></li></ul><h1 id="2-栈的应用"><a href="#2-栈的应用" class="headerlink" title="2. 栈的应用"></a>2. 栈的应用</h1><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a><strong>函数调用栈</strong></h3><p>递归算法所用的空间主要取决于递归的深度，而不是递归实例的总数（因为递归实例并不是同时出现，每层递归只调用一个递归实例）</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a><strong>尾递归</strong></h3><p>当每次递归只出现在最后一步时，这个递归就可以消除，时间上会有常系数的改进，空间上会大幅度改进</p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a><strong>进制转换</strong></h3><p>短除法，反复整除留余</p><p>要找到一种算法，可以自低而高的保留数位，然后自高而低的输出</p><p>栈就是这样一种满足要求的数据结构</p><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>分治策略和减治策略是不可行的，他们只满足充分条件，不满足必要条件，这是一种由外而内的策略</p><p><img src="/Users/markov/Desktop/blog/source/img/e623455616f7414ab351c7903eaec48.jpg" alt="e623455616f7414ab351c7903eaec48"></p><p>思考一种由内而外的策略，从内部一点一点将紧邻的括号消去从而判断是否全局匹配，要想实现这种策略，可以考虑使用栈</p><p><img src="/Users/markov/Desktop/blog/source/img/4e95db1e7942d27c6250eca1540af12.jpg" alt="4e95db1e7942d27c6250eca1540af12"></p><h3 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h3><p>考察栈 $A,B,S$，只存在 $S.push(A.pop()),B.push(S.pop())$两个操作</p><p>可以考察 $S$再度变空 $n$种情况，实际上就是对 $A$中除第一个元素外（因为第一个元素必然排在 $k$个元素的末尾）前 $k-1$个元素栈混洗再对后 $n-k$个元素栈混洗</p><p>因此最后得到的组合数为</p><p>$SP(n)&#x3D;\sum SP(k-1)\cdot SP(n-k)&#x3D;catalan(n)&#x3D;\frac{(2n)!}{(n+1)!\cdot n!}$</p><p><strong>检测禁形</strong></p><p>对任何 $1≤i&lt;j&lt;k≤n,[…,k,…,i,…,j,…&gt;$，必然不是栈混洗</p><p>即不存在“312”的模式</p><p><strong>括号匹配</strong></p><p>$S$经历了n次push和n次pop正好对应n对括号的匹配，所以n对括号匹配的排序数量也是卡特兰数</p><h3 id="中缀表达式求值"><a href="#中缀表达式求值" class="headerlink" title="中缀表达式求值"></a>中缀表达式求值</h3><p>要先按照规则约定一个优先级，还要考察括号优先级</p><h3 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h3><p>不使用括号，即可表示带优先级的运算关系，也可以称为后缀式</p><p>用一个栈，遇到数就压入，遇到算符就弹出计算，更方便（好像）</p><p><strong>中缀表达式与逆波兰表达式转换</strong></p><p>将中缀表达式的每一次运算都用括号括起来，然后按照左括号和数字向下，运算符向上的规则写成一个起起伏伏的序列，这样每一个运算符都在同一高度上对应着一个右括号，然后将运算符移动到右括号对应的位置替换掉右括号，最后再落到同一排，转换就完成了</p><p><img src="/Users/markov/Desktop/blog/source/img/ed0ecda2e7675d6d2c12ed83b9e0161.jpg" alt="ed0ecda2e7675d6d2c12ed83b9e0161"></p><h1 id="3-队列的接口与实现"><a href="#3-队列的接口与实现" class="headerlink" title="3. 队列的接口与实现"></a>3. 队列的接口与实现</h1><p>队列只能在队尾插入，从队头删除，先进先出</p><ul><li>接口<ul><li>enqueue()&#x2F;rear()</li><li>dequeue()&#x2F;front()</li></ul></li></ul><h1 id="4-队列应用"><a href="#4-队列应用" class="headerlink" title="4. 队列应用"></a>4. 队列应用</h1><h3 id="直方图内最大矩形"><a href="#直方图内最大矩形" class="headerlink" title="直方图内最大矩形"></a>直方图内最大矩形</h3><p><strong>蛮力算法(Brute force)</strong></p><p>逐一扫描选取最大的，复杂度 $O(n^{2})$</p><p><strong>优化算法</strong></p><p>对每一个直方矩形，找到它的左边界和右边界存起来即可，在找的过程中要进行适当的剪枝</p><h1 id="5-栈与队列"><a href="#5-栈与队列" class="headerlink" title="5. 栈与队列"></a>5. 栈与队列</h1><h3 id="Steap-Stack-Heap"><a href="#Steap-Stack-Heap" class="headerlink" title="Steap &#x3D; Stack + Heap"></a>Steap &#x3D; Stack + Heap</h3><p><img src="/Users/markov/Desktop/blog/source/img/1f6d3f3d79fe9975ddd9715022d7525.jpg" alt="1f6d3f3d79fe9975ddd9715022d7525"></p><p>这样可以快速得出栈中最大的元素，但是 $P$中存了大量重复的元素似乎有些浪费空间，可以对其进行适当的简化：</p><p><img src="/Users/markov/Desktop/blog/source/img/dad44ff2f88dfb585c38ac5092a116f.jpg" alt="dad44ff2f88dfb585c38ac5092a116f"></p><p>用压缩的方法，每个最大值部分存一个计数器，来了pop一个就-1，来更大的就push一个</p><h3 id="Queap-Queue-Heap"><a href="#Queap-Queue-Heap" class="headerlink" title="Queap &#x3D; Queue + Heap"></a>Queap &#x3D; Queue + Heap</h3><p><img src="/Users/markov/Desktop/blog/source/img/b276f1fcf9a3bd160aa344ab69864b7.jpg" alt="b276f1fcf9a3bd160aa344ab69864b7"></p><p>用队列时，更新复杂度就会变高，因为插入是从后缀插入， $P$要更新后缀的最大值</p><p>同样的也可以用压缩的方法降低空间复杂度</p><p><strong>为什么 $P$的后缀可进可出？</strong></p><h3 id="双栈当队"><a href="#双栈当队" class="headerlink" title="双栈当队"></a>双栈当队</h3><p><strong>复杂度分析</strong></p><ul><li>Accounting</li></ul><p>思考每个元素要进行的操作数，无非入栈、出栈、再入栈、再出栈四种 $O(1)$操作，因此分摊复杂度是 $O(4)$，这个以元素为研究对象</p><ul><li>Aggregate（校长算总账）</li></ul><p>考虑队列是个学校，所有入过学的总数为 $e$，所有毕业的总数为 $d$，总共所花时间无非 $≤4d+3(e-d)$，则每次操作的分摊复杂度为 $\frac{3e+d}{e+d}&lt;3$，这个以操作为研究对象</p><ul><li>Potential（势能）</li></ul><p>很玄学的一个东西</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-03%20List/"/>
    <url>/2023/08/14/PS-03%20List/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-03-List"><a href="#PS-03-List" class="headerlink" title="PS-03 List"></a>PS-03 List</h1><p>[TOC]</p><h1 id="1-从向量到列表"><a href="#1-从向量到列表" class="headerlink" title="1. 从向量到列表"></a>1. 从向量到列表</h1><h3 id="循位置访问"><a href="#循位置访问" class="headerlink" title="循位置访问"></a>循位置访问</h3><p>列表中各元素的物理位置不决定于逻辑位置,利用节点之间相互引用，找到特定的节点</p><p>动态操作复杂度为 $O(1)$</p><h3 id="ADT接口"><a href="#ADT接口" class="headerlink" title="ADT接口"></a>ADT接口</h3><p><img src="/Users/markov/Desktop/blog/source/img/f9b0a8ed03e6a35753c3b12420da6fe.jpg" alt="f9b0a8ed03e6a35753c3b12420da6fe"></p><h1 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2. 无序列表"></a>2. 无序列表</h1><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>进行一个指针的换向就OK了</p><p><img src="/Users/markov/Desktop/blog/source/img/a714f74f5f64f98cee3826d7876e79e.jpg" alt="a714f74f5f64f98cee3826d7876e79e"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>仍然是进行指针的换向<img src="/Users/markov/Desktop/blog/source/img/801eed1f8f0c104bbdf903a593150da.jpg" alt="801eed1f8f0c104bbdf903a593150da"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>列表二分查找的成本太高，因此只采取顺序查找</p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>与无序向量的去重方法相同</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>顺序遍历</p><h1 id="3-有序向量"><a href="#3-有序向量" class="headerlink" title="3. 有序向量"></a>3. 有序向量</h1><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h3><p>感觉和有序向量的勤奋算法是一样的思路，但是列表的动态删除是 $O(1)$的时间，所以复杂度也只是 $O(n)$</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>仍然是顺序查找，仍然能满足向量的找到不大于e的最大的节点，从而保证插入的有序和稳定性</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>如果用冒泡排序，每次扫描需要 $O(n)$次比较， $O(n)$次交换，而列表的交换又比较慢且没有必要，所以用选择排序，在每次扫描找到最大者，交换一次即可。选择排序相比与起泡排序，优化的是常数项</p><p><strong>性能分析</strong></p><p>复杂度仍为 $\Theta (n^{2})$，但时间都花在了比较上</p><h1 id="4-循环节"><a href="#4-循环节" class="headerlink" title="4. 循环节"></a>4. 循环节</h1><p>一个元素占了另一个元素的位置，这个元素又占了另另一个元素的位置，这样循环下去，最终回到起点（类似三角债），这样就构成了一个循环节</p><p>选择排序每交换一次，最大元素就跳出了原来的循环节，独立成一个新的循环节</p><p>当循环节达到 $n$个时，排序就完成了</p><h1 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5. 插入排序"></a>5. 插入排序</h1><p><strong>一个在线的算法</strong></p><p>首先有一个有序序列（长度可能为0），对于每一个新来的元素，找到合适的位置插入即可</p><p>从期望的意义上来讲，时间复杂度为 $O(n^{2})$</p><ul><li><p>略证</p><p>插入 $S[r]$所花时间为 $1+\sum^{r}k&#x2F;(r+1)&#x3D;1+r&#x2F;2$</p><p>插入 $n$个所花期望总时间为 $\sum^{n-1}(1+r&#x2F;2)&#x3D;O(n^{2})$</p></li></ul><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><p>复杂度依然为 $O(nlogn)$</p><h1 id="7-逆序对"><a href="#7-逆序对" class="headerlink" title="7. 逆序对"></a>7. 逆序对</h1><p>如果 $0≤i&lt;j&lt;n,A[i]&gt;A[j]$，则称其为一逆序对</p><p>逆序对总数 $≤O(n^{2})$</p><p><strong>Bubblesort</strong></p><p>起泡排序的每次交换都会使整体逆序对的个数减1，因此交换的总次数为逆序对总数</p><p><strong>Insertionsort</strong></p><p>运行时间为逆序对个数+n</p><p><strong>统计逆序对个数</strong></p><p>借助归并排序，复杂度为 $O(nlogn)$<strong>为什么？？？</strong></p><h1 id="8-游标实现"><a href="#8-游标实现" class="headerlink" title="8. 游标实现"></a>8. 游标实现</h1><p>用双数组来模拟链表，但是是单向的列表，也可以用三数组来模拟列表</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/14/PS-02%20Vector/"/>
    <url>/2023/08/14/PS-02%20Vector/</url>
    
    <content type="html"><![CDATA[<h1 id="PS-02-Vector"><a href="#PS-02-Vector" class="headerlink" title="PS-02 Vector"></a>PS-02 Vector</h1><p>[TOC]</p><h1 id="1-从数组到向量"><a href="#1-从数组到向量" class="headerlink" title="1. 从数组到向量"></a>1. 从数组到向量</h1><h3 id="寻秩访问"><a href="#寻秩访问" class="headerlink" title="寻秩访问"></a>寻秩访问</h3><p>其实就和数组一样…</p><h3 id="向量ADT接口"><a href="#向量ADT接口" class="headerlink" title="向量ADT接口"></a>向量ADT接口</h3><p><img src="/Users/markov/Desktop/blog/source/img/45b2bec29dbaf4cc63c273ddb4719a6.jpg" alt="45b2bec29dbaf4cc63c273ddb4719a6"></p><h3 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h3><p>开辟内部数组并使用一段地址连续的物理空间</p><p>$capacity$：总容量</p><p>$size$：实际规模</p><p>静态管理时容易出现 $size&gt;capacity$或 $size\ll capacity$的情况，以至上溢或者下溢，因此需要动态调整容量</p><p><strong>动态空间管理</strong></p><p>在即将上溢时，将向量的容量加倍，注意还需要将原来向量的元素迁移到新的向量中，时间复杂度为 $O(n)$</p><p>(但是这种情况并不是总是发生的)</p><p><strong>分摊分析</strong></p><p>每次扩容过程所需时间的加和&#x3D; $1+2+4+…+2^{m-1}$是几何级数，最终复杂度为 $O(n)$，但分摊到 $n$次扩容中去，复杂度不过是 $O(1)$的</p><p><strong>思考</strong>：如果不采取容量加倍策略，其他的扩容策略比如递增策略是否可行？</p><p>如果采取递增策略，扩容所需时间是算数级数 $O(n^{2})$，分摊后为 $O(n)$</p><p><img src="/Users/markov/Desktop/blog/source/img/21dca81624b9eb707679a150513b29e.jpg" alt="21dca81624b9eb707679a150513b29e"></p><h1 id="2-无序向量"><a href="#2-无序向量" class="headerlink" title="2. 无序向量"></a>2. 无序向量</h1><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h3><ul><li>插入：先扩容or not，然后插入</li><li>删除：先写区间删除的操作，单元素删除时调用区间删除</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h3><p>一种基于比较和判等的查找方法（与后面要学的哈希表的查找方法不同）</p><p>从后向前比较，输入敏感，复杂度 $O(n)$</p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a><strong>去重</strong></h3><p>去重，从头开始，拿出一个位置的元素向前查找，找到则删除，复杂度为 $O(n^{2})$</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><h1 id="3-有序向量"><a href="#3-有序向量" class="headerlink" title="3. 有序向量"></a>3. 有序向量</h1><p><strong>无序向量处理为有序向量之后相关算法可优化</strong></p><h3 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a><strong>唯一化</strong></h3><ul><li>低效算法：从前向后逐一比对，相同则删除，但是删除算法本身的复杂度就是 $O(size-i)$，因此该方法很低效。此时向量已经是有序的了，重复的元素都聚集在一起，可以思考批量删除的方法。</li><li>高效算法：使用两个索引 $i,j$， $j$一直向前试探， $i$留在原地不动，当 $elem[i]≠elem[j]$时，把 $j$对应的元素丢到前面来，这样就完成了一批删除操作。</li></ul><p><img src="/Users/markov/Desktop/blog/source/img/4d15f92d5b570685b4de2487a96215a.jpg" alt="4d15f92d5b570685b4de2487a96215a"></p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p><strong>二分查找（版本A）</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/997575a1b7e9cbe84e28ee9e34be8b2.jpg" alt="997575a1b7e9cbe84e28ee9e34be8b2"></p><p>分为了三种情况， $[lo,mi),[mi],[mi+1,hi)$，时间复杂度 $O(logn)$，这种方法的缺点是每次循环可能要比较两次，且数据类型比较所花的时间可能会比较长</p><p>成功、失败时的平均查找长度均大致为 $O(1.50\cdot logn)$</p><p><strong>二分查找（版本B）</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/7512a62fa1be1964d8d5c1f6b36eb8e.jpg" alt="7512a62fa1be1964d8d5c1f6b36eb8e"></p><p>相比于版本A，版本B每次迭代少了一次比较，分为两种情况 $[lo,mi),[mi,hi)$，但迭代的深度必然达到 $logn$。相比版本A，最好(坏)的情况下更坏(好),性能更均衡</p><p>但是为了维护向量的<strong>有序性</strong>（即使查找失败也要给出适当的位置）和<strong>稳定性</strong>（重复元素也要按照插入次序排列），还需要查找算法在目标不存在时和目标存在多个时都返回一个有效的秩</p><p>约定总是返回小于等于查找元素 $e$的元素的最大的秩，为此还需更好的实现方式！</p><p><strong>二分查找（版本C）</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/64078c0af42f7d7af0239beae15ae8e.jpg" alt="64078c0af42f7d7af0239beae15ae8e"></p><p>这个方法在每次迭代的过程中，大胆地跳过了 $S[mi]$，但这种方法是能满足要求并且非常正确的！</p><p>从循环不变性的角度来看， $A[0,lo)≤e&lt;A[hi,n)$， 在已知的范围内，$A[lo-1]$总是目前不大于e的最大者， $A[hi]$总是大于e的最小者</p><p><img src="/Users/markov/Desktop/blog/source/img/44c285d68d03979d219a3c7a9f21952.jpg" alt="44c285d68d03979d219a3c7a9f21952"></p><p><strong>插值查找</strong></p><p>当数据量足够庞大时，数据近似呈线性分布，因此可采取线性的插值方法来插入元素</p><p>（数据的分布可能不是线性，但依然可以按照其他规律来插值）</p><p>性能： $O(loglogn)$<strong>为什么？？？（有待求问）</strong></p><p>在数据范围很大时，插值查找有明显的优势，但数据量不是非常大时，优势也不是很明显，引入了乘法除法运算反而不好</p><p>实际可行的方法：</p><ul><li>先插值查找缩小数据范围</li><li>再二分查找进一步缩小范围</li><li>最后顺序查找</li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>起泡排序</li><li>选择排序</li><li>归并排序</li><li>堆排序</li><li>快速排序</li><li>希尔排序</li></ul><p><strong>起泡排序</strong></p><p>依次比较每一对相邻的元素，如果逆序则交换之，反复扫描，直到确认顺序</p><p>提前终止版：</p><p>经过反复扫描之后，有可能前缀就已经有序了，这时就不用再扫描了，可以提前终止</p><p>跳跃版：</p><p>有可能后缀已经有序了，每次扫描的终止位置可以提前</p><p><strong>以上起泡排序算法都是稳定的</strong></p><p><strong>归并排序</strong></p><p><img src="/Users/markov/Desktop/blog/source/img/abe5817bcb465c186c88101190d2a81.jpg" alt="abe5817bcb465c186c88101190d2a81"></p><p><img src="/Users/markov/Desktop/blog/source/img/b7f6965c350d5dc9b59a01bbd076973.jpg" alt="b7f6965c350d5dc9b59a01bbd076973"></p><p><img src="/Users/markov/Desktop/blog/source/img/8bf861e667f2353b3a6fe5f39e67d16.jpg" alt="8bf861e667f2353b3a6fe5f39e67d16"></p><p>复杂度： $O(nlogn)$</p><h1 id="4-位图（bit-map"><a href="#4-位图（bit-map" class="headerlink" title="4. 位图（bit map)"></a>4. 位图（bit map)</h1><p><strong>一种针对有限整数集的数据结构</strong></p><p>取一段连续的存储单元（bit），如果元素存在，则相应位置的bit置为1，否则为0</p><p>可实现去重和排序，复杂度均为 $O(n)$</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
